import { test, expect, devices } from '@playwright/test';\nimport { HomePage } from './page-objects/homepage';\nimport { ProductPage } from './page-objects/product-page';\nimport { CartPage } from './page-objects/cart-page';\nimport { SearchPage } from './page-objects/search-page';\nimport { VisualRegressionHelper } from '../utils/visual-regression-helper';\nimport { PerformanceHelper } from '../utils/performance-helper';\nimport { AccessibilityHelper } from '../utils/accessibility-helper';\n\n/**\n * Mobile and Touch Interaction Tests\n * \n * Tests specifically designed for mobile devices with touch interactions:\n * - Touch gestures (tap, swipe, pinch, long press)\n * - Mobile navigation patterns\n * - Responsive design validation\n * - Mobile performance optimization\n * - Touch accessibility\n * - PWA features\n * - Mobile-specific user flows\n */\n\ntest.describe('Mobile Touch Interactions - Heaven-Dolls', () => {\n  let homePage: HomePage;\n  let productPage: ProductPage;\n  let cartPage: CartPage;\n  let searchPage: SearchPage;\n  let visualHelper: VisualRegressionHelper;\n  let performanceHelper: PerformanceHelper;\n  let accessibilityHelper: AccessibilityHelper;\n\n  test.beforeEach(async ({ page, browserName }) => {\n    // Initialize page objects\n    homePage = new HomePage(page);\n    productPage = new ProductPage(page);\n    cartPage = new CartPage(page);\n    searchPage = new SearchPage(page);\n    \n    // Initialize helpers\n    visualHelper = new VisualRegressionHelper(page, browserName);\n    performanceHelper = new PerformanceHelper(page);\n    accessibilityHelper = new AccessibilityHelper(page);\n    \n    // Clear storage\n    await page.evaluate(() => {\n      localStorage.clear();\n      sessionStorage.clear();\n    });\n  });\n\n  test.describe('Touch Gesture Interactions', () => {\n    test('should handle basic touch gestures correctly', async ({ page }) => {\n      await homePage.navigate();\n      await homePage.verifyPageLoaded();\n\n      // Test tap gesture on product card\n      const productCard = homePage.productCard;\n      await productCard.dispatchEvent('touchstart', {\n        touches: [{ clientX: 100, clientY: 100 }]\n      });\n      await page.waitForTimeout(50);\n      await productCard.dispatchEvent('touchend');\n      \n      // Should navigate to product page\n      await expect(page).toHaveURL(/\\/products\\/.+/);\n      \n      // Visual test of product page on mobile\n      await visualHelper.compareFullPage('mobile-product-page');\n    });\n\n    test('should support swipe gestures on image carousel', async ({ page }) => {\n      await homePage.navigate();\n      await homePage.clickFirstProduct();\n      await productPage.verifyPageLoaded();\n\n      const imageCarousel = page.locator('[data-testid=\"image-carousel\"], [data-testid=\"product-gallery\"]');\n      \n      if (await imageCarousel.isVisible()) {\n        const carouselBox = await imageCarousel.boundingBox();\n        if (carouselBox) {\n          // Swipe left gesture\n          await page.touchscreen.tap(\n            carouselBox.x + carouselBox.width * 0.8, \n            carouselBox.y + carouselBox.height * 0.5\n          );\n          \n          await page.touchscreen.tap(\n            carouselBox.x + carouselBox.width * 0.2, \n            carouselBox.y + carouselBox.height * 0.5\n          );\n          \n          await page.waitForTimeout(500);\n          \n          // Visual test after swipe\n          await visualHelper.compareElement(imageCarousel, 'carousel-after-swipe');\n        }\n      }\n    });\n\n    test('should handle long press for context menu', async ({ page }) => {\n      await homePage.navigate();\n      await homePage.verifyPageLoaded();\n\n      const productCard = homePage.productCard;\n      \n      // Long press gesture (touch and hold)\n      await productCard.dispatchEvent('touchstart', {\n        touches: [{ clientX: 100, clientY: 100 }]\n      });\n      \n      // Hold for 1 second\n      await page.waitForTimeout(1000);\n      \n      await productCard.dispatchEvent('touchend');\n      \n      // Check if context menu or quick actions appeared\n      const quickActions = page.locator('[data-testid=\"quick-actions\"], .context-menu');\n      if (await quickActions.isVisible()) {\n        await visualHelper.compareFullPage('mobile-context-menu');\n      }\n    });\n\n    test('should support pull-to-refresh functionality', async ({ page }) => {\n      await homePage.navigate();\n      await homePage.verifyPageLoaded();\n\n      // Simulate pull-to-refresh gesture\n      const startY = 50;\n      const endY = 200;\n      \n      await page.touchscreen.tap(page.viewportSize()!.width / 2, startY);\n      \n      // Drag down\n      await page.mouse.move(page.viewportSize()!.width / 2, startY);\n      await page.mouse.down();\n      await page.mouse.move(page.viewportSize()!.width / 2, endY);\n      await page.waitForTimeout(100);\n      await page.mouse.up();\n      \n      // Check for refresh indicator\n      const refreshIndicator = page.locator('[data-testid=\"refresh-indicator\"], .pull-to-refresh');\n      if (await refreshIndicator.isVisible()) {\n        await expect(refreshIndicator).toBeVisible();\n        await page.waitForTimeout(2000); // Wait for refresh to complete\n      }\n    });\n  });\n\n  test.describe('Mobile Navigation Patterns', () => {\n    test('should provide excellent mobile navigation experience', async ({ page }) => {\n      await page.setViewportSize({ width: 375, height: 667 }); // iPhone SE size\n      \n      await homePage.navigate();\n      await homePage.verifyPageLoaded();\n\n      // Test hamburger menu\n      await homePage.openMobileMenu();\n      await visualHelper.compareFullPage('mobile-menu-open');\n      \n      // Test menu navigation\n      const mobileMenu = page.getByTestId('mobile-menu');\n      await mobileMenu.getByRole('link', { name: /products|shop/i }).tap();\n      \n      await expect(page).toHaveURL(/\\/products/);\n      await page.waitForLoadState('networkidle');\n      \n      // Test bottom navigation (if present)\n      const bottomNav = page.locator('[data-testid=\"bottom-navigation\"], .bottom-nav');\n      if (await bottomNav.isVisible()) {\n        await visualHelper.compareElement(bottomNav, 'mobile-bottom-navigation');\n        \n        // Test bottom nav interaction\n        const homeTab = bottomNav.getByRole('button', { name: /home/i });\n        if (await homeTab.isVisible()) {\n          await homeTab.tap();\n          await expect(page).toHaveURL('/');\n        }\n      }\n    });\n\n    test('should handle mobile search with predictive suggestions', async ({ page }) => {\n      await page.setViewportSize({ width: 375, height: 667 });\n      \n      await homePage.navigate();\n      \n      // Open mobile search\n      const searchButton = page.getByRole('button', { name: /search/i });\n      if (await searchButton.isVisible()) {\n        await searchButton.tap();\n      }\n      \n      const searchInput = page.getByRole('searchbox');\n      await searchInput.tap();\n      await searchInput.type('well', { delay: 100 });\n      \n      // Wait for suggestions to appear\n      await page.waitForTimeout(500);\n      \n      const suggestions = page.locator('[data-testid=\"search-suggestions\"], .search-dropdown');\n      if (await suggestions.isVisible()) {\n        await visualHelper.compareFullPage('mobile-search-suggestions');\n        \n        // Tap on first suggestion\n        const firstSuggestion = suggestions.locator('button, a').first();\n        await firstSuggestion.tap();\n        \n        // Should navigate to search results\n        await searchPage.verifyPageLoaded();\n      } else {\n        // Complete typing and search\n        await searchInput.type('ness');\n        await page.keyboard.press('Enter');\n        await searchPage.verifyPageLoaded();\n      }\n      \n      await visualHelper.compareFullPage('mobile-search-results');\n    });\n\n    test('should provide mobile-optimized filters and sorting', async ({ page }) => {\n      await page.setViewportSize({ width: 375, height: 667 });\n      \n      await page.goto('/products');\n      await page.waitForLoadState('networkidle');\n      \n      // Test mobile filter drawer\n      const filterButton = page.getByRole('button', { name: /filter|filters/i });\n      await filterButton.tap();\n      \n      const filterDrawer = page.locator('[data-testid=\"filter-drawer\"], .filter-modal');\n      await expect(filterDrawer).toBeVisible();\n      \n      await visualHelper.compareFullPage('mobile-filter-drawer');\n      \n      // Test filter interactions\n      const priceFilter = filterDrawer.getByText(/price/i);\n      if (await priceFilter.isVisible()) {\n        await priceFilter.tap();\n        \n        // Test price range slider on mobile\n        const priceSlider = filterDrawer.locator('[data-testid=\"price-slider\"], input[type=\"range\"]');\n        if (await priceSlider.first().isVisible()) {\n          const slider = priceSlider.first();\n          const sliderBox = await slider.boundingBox();\n          \n          if (sliderBox) {\n            // Touch and drag slider\n            await page.touchscreen.tap(\n              sliderBox.x + sliderBox.width * 0.3,\n              sliderBox.y + sliderBox.height * 0.5\n            );\n          }\n        }\n      }\n      \n      // Apply filters\n      const applyButton = filterDrawer.getByRole('button', { name: /apply/i });\n      await applyButton.tap();\n      \n      await page.waitForLoadState('networkidle');\n      await visualHelper.compareFullPage('mobile-filtered-products');\n      \n      // Test mobile sorting\n      const sortButton = page.getByRole('button', { name: /sort/i });\n      if (await sortButton.isVisible()) {\n        await sortButton.tap();\n        \n        const sortOptions = page.locator('[data-testid=\"sort-options\"], .sort-modal');\n        await expect(sortOptions).toBeVisible();\n        \n        await visualHelper.compareFullPage('mobile-sort-options');\n        \n        // Select a sort option\n        const priceSort = sortOptions.getByText(/price.*low.*high|price.*ascending/i);\n        if (await priceSort.isVisible()) {\n          await priceSort.tap();\n        }\n        \n        await page.waitForLoadState('networkidle');\n      }\n    });\n  });\n\n  test.describe('Mobile Shopping Cart Experience', () => {\n    test('should provide optimized mobile cart experience', async ({ page }) => {\n      await page.setViewportSize({ width: 375, height: 667 });\n      \n      await homePage.navigate();\n      await homePage.clickFirstProduct();\n      await productPage.verifyPageLoaded();\n      \n      // Mobile add to cart\n      const addToCartButton = page.getByRole('button', { name: /add to cart/i });\n      await addToCartButton.tap();\n      \n      // Test mobile cart drawer\n      await page.waitForTimeout(1000);\n      const cartDrawer = page.locator('[data-testid=\"cart-drawer\"], .cart-sidebar');\n      \n      if (await cartDrawer.isVisible()) {\n        await visualHelper.compareFullPage('mobile-cart-drawer-open');\n        \n        // Test quantity controls on mobile\n        const quantityControls = cartDrawer.locator('[data-testid=\"quantity-controls\"]');\n        if (await quantityControls.isVisible()) {\n          const increaseButton = quantityControls.getByRole('button', { name: /\\+|increase/i });\n          await increaseButton.tap();\n          \n          await page.waitForTimeout(500);\n          await visualHelper.compareElement(cartDrawer, 'mobile-cart-quantity-updated');\n        }\n        \n        // Test remove item on mobile\n        const removeButton = cartDrawer.getByRole('button', { name: /remove|delete/i });\n        if (await removeButton.isVisible()) {\n          await removeButton.tap();\n          \n          // Handle confirmation if it appears\n          const confirmButton = page.getByRole('button', { name: /confirm|yes|remove/i });\n          if (await confirmButton.isVisible()) {\n            await confirmButton.tap();\n          }\n          \n          await page.waitForTimeout(500);\n        }\n        \n        // Navigate to full cart\n        const viewCartButton = cartDrawer.getByRole('button', { name: /view cart/i });\n        if (await viewCartButton.isVisible()) {\n          await viewCartButton.tap();\n          \n          await expect(page).toHaveURL(/\\/cart/);\n          await visualHelper.compareFullPage('mobile-full-cart-page');\n        }\n      }\n    });\n\n    test('should support mobile checkout process', async ({ page }) => {\n      await page.setViewportSize({ width: 375, height: 667 });\n      \n      // Add item to cart first\n      await homePage.navigate();\n      await homePage.clickFirstProduct();\n      await productPage.addToCart(1);\n      \n      // Navigate to checkout\n      await cartPage.proceedToCheckout();\n      \n      // Test mobile checkout form\n      await page.waitForLoadState('networkidle');\n      \n      // Handle guest checkout\n      const guestCheckoutOption = page.getByRole('radio', { name: /guest/i });\n      if (await guestCheckoutOption.isVisible()) {\n        await guestCheckoutOption.tap();\n      }\n      \n      await visualHelper.compareFullPage('mobile-checkout-form');\n      \n      // Test mobile form fields\n      const firstNameInput = page.getByLabel(/first name/i);\n      await firstNameInput.tap();\n      await firstNameInput.fill('John');\n      \n      // Test mobile keyboard handling\n      const emailInput = page.getByLabel(/email/i);\n      await emailInput.tap();\n      await emailInput.fill('john@example.com');\n      \n      const phoneInput = page.getByLabel(/phone/i);\n      await phoneInput.tap();\n      await phoneInput.fill('555-123-4567');\n      \n      // Visual test of filled form on mobile\n      await visualHelper.compareFullPage('mobile-checkout-form-filled');\n      \n      // Test mobile payment section\n      const paymentSection = page.locator('[data-testid=\"payment-section\"]');\n      if (await paymentSection.isVisible()) {\n        await visualHelper.compareElement(paymentSection, 'mobile-payment-section');\n        \n        // Test credit card input formatting on mobile\n        const cardNumberInput = page.getByLabel(/card number/i);\n        if (await cardNumberInput.isVisible()) {\n          await cardNumberInput.tap();\n          await cardNumberInput.type('4242424242424242');\n          \n          // Should format with spaces\n          await expect(cardNumberInput).toHaveValue('4242 4242 4242 4242');\n        }\n      }\n    });\n  });\n\n  test.describe('PWA and Mobile Features', () => {\n    test('should support PWA features on mobile', async ({ page }) => {\n      await page.setViewportSize({ width: 375, height: 667 });\n      \n      await homePage.navigate();\n      \n      // Check for PWA manifest\n      const manifestLink = page.locator('link[rel=\"manifest\"]');\n      if (await manifestLink.count() > 0) {\n        const manifestHref = await manifestLink.getAttribute('href');\n        expect(manifestHref).toBeTruthy();\n      }\n      \n      // Test add to home screen functionality\n      const addToHomeButton = page.getByText(/add to home screen|install app/i);\n      if (await addToHomeButton.isVisible()) {\n        await visualHelper.compareFullPage('pwa-install-prompt');\n      }\n      \n      // Test offline functionality\n      await page.context().setOffline(true);\n      \n      try {\n        await page.reload();\n        await page.waitForLoadState('networkidle', { timeout: 5000 });\n        \n        // Should show offline message or cached content\n        const offlineMessage = page.getByText(/offline|no connection|cached/i);\n        if (await offlineMessage.isVisible()) {\n          await visualHelper.compareFullPage('mobile-offline-state');\n        }\n      } catch (error) {\n        console.log('Offline functionality not available');\n      } finally {\n        await page.context().setOffline(false);\n      }\n    });\n\n    test('should handle mobile notifications', async ({ page }) => {\n      await page.setViewportSize({ width: 375, height: 667 });\n      \n      // Grant notification permissions\n      const context = page.context();\n      await context.grantPermissions(['notifications']);\n      \n      await homePage.navigate();\n      \n      // Test notification opt-in\n      const notificationPrompt = page.getByText(/allow notifications|enable notifications/i);\n      if (await notificationPrompt.isVisible()) {\n        await visualHelper.compareFullPage('mobile-notification-prompt');\n        \n        const allowButton = page.getByRole('button', { name: /allow|enable/i });\n        await allowButton.tap();\n      }\n      \n      // Test cart abandonment notification (if implemented)\n      await homePage.clickFirstProduct();\n      await productPage.addToCart(1);\n      \n      // Navigate away to simulate cart abandonment\n      await homePage.navigate();\n      \n      // Wait for potential notification\n      await page.waitForTimeout(3000);\n    });\n  });\n\n  test.describe('Mobile Performance Optimization', () => {\n    test('should meet mobile performance benchmarks', async ({ page }) => {\n      // Simulate slow 3G connection\n      const client = await page.context().newCDPSession(page);\n      await client.send('Network.enable');\n      await client.send('Network.emulateNetworkConditions', {\n        offline: false,\n        downloadThroughput: 1.6 * 1024 * 1024 / 8, // 1.6Mbps\n        uploadThroughput: 750 * 1024 / 8, // 750kbps\n        latency: 150 // 150ms\n      });\n      \n      await page.setViewportSize({ width: 375, height: 667 });\n      \n      // Test mobile performance\n      const mobileMetrics = await performanceHelper.testMobilePerformance('/');\n      \n      // Mobile-specific performance assertions\n      expect(mobileMetrics.loadTime).toBeLessThan(5000); // 5s for slow 3G\n      expect(mobileMetrics.totalTransferSize).toBeLessThan(1000 * 1024); // 1MB\n      \n      if (mobileMetrics.lcp) {\n        expect(mobileMetrics.lcp).toBeLessThan(4000); // Mobile LCP threshold\n      }\n      \n      // Test image loading performance on mobile\n      const imagePerf = await performanceHelper.testImageLoadingPerformance();\n      expect(imagePerf.lazyLoadedImages).toBeGreaterThan(0); // Should use lazy loading\n      \n      console.log(`📱 Mobile performance: ${Math.round(mobileMetrics.loadTime)}ms load time`);\n      console.log(`📊 Transfer size: ${Math.round(mobileMetrics.totalTransferSize / 1024)}KB`);\n    });\n\n    test('should optimize mobile scrolling performance', async ({ page }) => {\n      await page.setViewportSize({ width: 375, height: 667 });\n      \n      await page.goto('/products');\n      await page.waitForLoadState('networkidle');\n      \n      // Test scroll performance\n      const scrollPerf = await performanceHelper.testScrollPerformance();\n      \n      // Mobile scroll should maintain good FPS\n      expect(scrollPerf.averageFPS).toBeGreaterThan(50); // 50+ FPS\n      expect(scrollPerf.jankyFrames).toBeLessThan(10); // Low jank\n      \n      console.log(`📱 Mobile scroll: ${scrollPerf.averageFPS} FPS, ${scrollPerf.jankyFrames} janky frames`);\n    });\n  });\n\n  test.describe('Mobile Accessibility', () => {\n    test('should meet mobile accessibility standards', async ({ page }) => {\n      await page.setViewportSize({ width: 375, height: 667 });\n      \n      await homePage.navigate();\n      \n      // Test mobile accessibility\n      await accessibilityHelper.testMobileAccessibility();\n      \n      // Test touch target sizes\n      const touchTargets = page.locator('button, a, input, select, [role=\"button\"]');\n      const targetCount = await touchTargets.count();\n      \n      for (let i = 0; i < Math.min(targetCount, 20); i++) {\n        const target = touchTargets.nth(i);\n        if (await target.isVisible()) {\n          const box = await target.boundingBox();\n          if (box) {\n            expect(box.width).toBeGreaterThanOrEqual(44); // WCAG 2.1 AA requirement\n            expect(box.height).toBeGreaterThanOrEqual(44);\n          }\n        }\n      }\n      \n      // Test mobile screen reader compatibility\n      await accessibilityHelper.testScreenReaderCompatibility();\n      \n      // Test mobile keyboard navigation (external keyboard support)\n      await accessibilityHelper.testKeyboardNavigation();\n      \n      console.log('✅ Mobile accessibility tests passed');\n    });\n  });\n\n  test.describe('Device-Specific Testing', () => {\n    // Test on different mobile devices\n    [\n      { device: 'iPhone 12', ...devices['iPhone 12'] },\n      { device: 'iPhone SE', ...devices['iPhone SE'] },\n      { device: 'Pixel 5', ...devices['Pixel 5'] },\n      { device: 'Galaxy S9+', ...devices['Galaxy S9+'] },\n    ].forEach(({ device, ...deviceConfig }) => {\n      test(`should work correctly on ${device}`, async ({ browser }) => {\n        const context = await browser.newContext(deviceConfig);\n        const page = await context.newPage();\n        \n        const deviceHomePage = new HomePage(page);\n        const deviceVisualHelper = new VisualRegressionHelper(page, device.toLowerCase().replace(/\\s+/g, '-'));\n        \n        await deviceHomePage.navigate();\n        await deviceHomePage.verifyPageLoaded();\n        \n        // Device-specific visual test\n        await deviceVisualHelper.compareFullPage(`${device.toLowerCase().replace(/\\s+/g, '-')}-homepage`);\n        \n        // Test critical functionality\n        await deviceHomePage.clickFirstProduct();\n        const deviceProductPage = new ProductPage(page);\n        await deviceProductPage.verifyPageLoaded();\n        \n        // Add to cart test\n        await deviceProductPage.addToCart(1);\n        \n        const deviceCartPage = new CartPage(page);\n        await deviceCartPage.openCartDrawer();\n        await deviceCartPage.verifyCartHasItems();\n        \n        await context.close();\n      });\n    });\n  });\n\n  test.describe('Touch Gesture Edge Cases', () => {\n    test('should handle simultaneous touches (multi-touch)', async ({ page }) => {\n      await page.setViewportSize({ width: 375, height: 667 });\n      \n      await homePage.navigate();\n      await homePage.clickFirstProduct();\n      \n      const imageGallery = page.locator('[data-testid=\"image-gallery\"], .product-images');\n      \n      if (await imageGallery.isVisible()) {\n        const galleryBox = await imageGallery.boundingBox();\n        if (galleryBox) {\n          // Simulate pinch zoom gesture\n          await page.touchscreen.tap(\n            galleryBox.x + galleryBox.width * 0.4,\n            galleryBox.y + galleryBox.height * 0.5\n          );\n          \n          await page.touchscreen.tap(\n            galleryBox.x + galleryBox.width * 0.6,\n            galleryBox.y + galleryBox.height * 0.5\n          );\n          \n          // Should handle zoom or show zoom indicator\n          await page.waitForTimeout(500);\n          \n          const zoomIndicator = page.locator('[data-testid=\"zoom-indicator\"], .zoom-overlay');\n          if (await zoomIndicator.isVisible()) {\n            await visualHelper.compareFullPage('mobile-image-zoom');\n          }\n        }\n      }\n    });\n\n    test('should prevent accidental touches during scroll', async ({ page }) => {\n      await page.setViewportSize({ width: 375, height: 667 });\n      \n      await page.goto('/products');\n      await page.waitForLoadState('networkidle');\n      \n      const productGrid = page.locator('[data-testid=\"product-grid\"], .products-list');\n      \n      if (await productGrid.isVisible()) {\n        const gridBox = await productGrid.boundingBox();\n        if (gridBox) {\n          // Fast scroll gesture\n          await page.touchscreen.tap(\n            gridBox.x + gridBox.width * 0.5,\n            gridBox.y + gridBox.height * 0.8\n          );\n          \n          // Quick swipe up\n          await page.mouse.move(gridBox.x + gridBox.width * 0.5, gridBox.y + gridBox.height * 0.8);\n          await page.mouse.down();\n          await page.mouse.move(gridBox.x + gridBox.width * 0.5, gridBox.y + gridBox.height * 0.2, { steps: 5 });\n          await page.mouse.up();\n          \n          // Should scroll, not click on products\n          await page.waitForTimeout(1000);\n          \n          // Verify we're still on the products page (not navigated to a product)\n          await expect(page).toHaveURL(/\\/products/);\n        }\n      }\n    });\n  });\n});"